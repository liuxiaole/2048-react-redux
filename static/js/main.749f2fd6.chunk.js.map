{"version":3,"sources":["actions/tiles.js","actions/action-types.js","utils/index.js","actions/index.js","components/HeaderBox.js","actions/scores.js","components/GameOver.js","components/Tiles.js","components/GameBoard.js","components/Game.js","reducers/scores.js","reducers/tiles.js","reducers/index.js","index.js"],"names":["generateNewTile","dispatch","getState","coord","tiles","emptyTiles","flatten","map","rows","i","tile","j","filter","length","index","Math","floor","random","row","col","getRandomCoordinate","type","number","uuid","v4","moveTile","payload","ms","Promise","resolve","setTimeout","then","preMergeTile","mergeTile","startNewGame","size","MOVE_DIR","up","down","left","right","ScoreBox","label","score","children","className","connect","scores","onAnimationEnd","id","cleanRecentAddedScore","props","recentAddedScores","key","e","bestScore","onClick","Tile","classMap","newGenerated","newMerged","classNames","Object","keys","cls","join","y","style","transform","ownProps","animationName","flattenTiles","flatTiles","forEach","push","tileToMerge","sort","tile1","tile2","BackgroundGrids","grids","Array","fill","_","state","gameOver","gameStatus","href","Game","this","handleKeyPress","bind","handleSwiped","window","addEventListener","removeEventListener","ev","gameStarted","match","toLowerCase","move","preventDefault","dir","isMoving","moveChessBoard","movingPromise","addScore","checkGameStatus","fn","movable","bottomTile","rightTile","isMovable","updateBestScore","setGameOver","swipeOptions","reduce","options","replace","$0","$1","toUpperCase","preventDefaultTouchmoveEvent","Component","actions","dirOffset","nextCol","nextRow","nextTile","destCol","destRow","catch","reason","console","trace","max","localStorage","setItem","combineReducers","action","getInitialTiles","mapTiles","mapper","rowNum","colNum","item","tileToMove","composeEnhancers","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","compose","preloadedState","getItem","JSON","parse","store","createStore","rootReducer","applyMiddleware","thunk","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.749f2fd6.chunk.js","sourcesContent":["import * as ActionTypes from './action-types';\nimport { v4 } from 'node-uuid';\nimport flatten from 'lodash.flatten';\nimport { sleep } from '../utils';\n\nconst getRandomCoordinate = tiles => {\n  let emptyTiles = flatten(tiles.map((rows, i) => rows.map((tile, j) => {\n    if(tile) return null;\n    return [i, j];\n  }))).filter(tile => !!tile);\n\n  if (emptyTiles.length) {\n    let index = Math.floor(Math.random() * emptyTiles.length);\n    let [row, col] = emptyTiles[index];\n    return {row, col};\n  }\n  return null;\n};\n\nexport const generateNewTile = () => (dispatch, getState) => {\n  let { tiles } = getState();\n  let coord = getRandomCoordinate(tiles);\n  if (coord) {\n    dispatch({\n      type: ActionTypes.GENERATE_NEW_TILE,\n      number: Math.random() > 0.8 ? 4 : 2,\n      uuid: v4(),\n      ...coord\n    });\n    return true;\n  }\n  return false;\n};\n\nexport const moveTile = (payload /*={row, col, destRow, destCol}*/) => (dispatch) => {\n  dispatch({\n    type: ActionTypes.MOVE_TILE,\n    ...payload\n  });\n  return sleep(80).then(() => payload);\n};\n\nexport const preMergeTile = (payload /*={row, col, destRow, destCol}*/) => {\n  return {\n    type: ActionTypes.PRE_MERGE_TILE,\n    ...payload\n  };\n};\n\nexport const mergeTile = ({row, col}) => {\n  return {\n    type: ActionTypes.MERGE_TILE,\n    row, col\n  };\n};\n\nexport const resetNewMergedTileTag = ({row, col}) => {\n  return {\n    type: ActionTypes.RESET_NEW_MERGED_TILE_TAG,\n    row, col\n  };\n};\n\nexport const resetNewGeneratedTileTag = ({row, col}) => {\n  return {\n    type: ActionTypes.RESET_NEW_GENERATED_TILE_TAG,\n    row, col\n  };\n};\n\n","export const START_NEW_GAME = 'START_NEW_GAME';\nexport const GAME_OVER = 'GAME_OVER';\n\nexport const ADD_SCORE = 'ADD_SCORE';\nexport const CLEAN_RECENT_ADDED_SCORE = 'CLEAN_RECENT_ADDED_SCORE';\nexport const UPDATE_BEST_SCORE = 'UPDATE_BEST_SCORE';\n\nexport const GENERATE_NEW_TILE = 'GENERATE_NEW_TILE';\nexport const MERGE_TILE = 'MERGE_TILE';\nexport const PRE_MERGE_TILE = 'PRE_MERGE_TILE';\nexport const MOVE_TILE = 'MOVE_TILE';\n\nexport const RESET_NEW_MERGED_TILE_TAG = 'RESET_NEW_MERGED_TILE_TAG';\nexport const RESET_NEW_GENERATED_TILE_TAG = 'RESET_NEW_GENERATED_TILE_TAG';\n","import Promise from 'promise';\n\nexport const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\n\nexport const deepEach = (arr, fn) => arr.forEach(row => row.forEach(fn));\n","import * as ActionTypes from './action-types';\nimport { generateNewTile, preMergeTile, moveTile, mergeTile } from './tiles';\n\nexport const startNewGame = () => (dispatch, getState) => {\n  dispatch({\n    type: ActionTypes.START_NEW_GAME,\n    size: getState().size\n  });\n  dispatch(generateNewTile());\n  dispatch(generateNewTile());\n};\n\nexport const setGameOver = () => {\n  return {\n    type: ActionTypes.GAME_OVER\n  };\n};\n\nconst MOVE_DIR = {\n  up: [0, -1],\n  down: [0, 1],\n  left: [-1, 0],\n  right: [1, 0]\n};\n\nexport const moveChessBoard = (dir) => (dispatch, getState) => {\n  let { size, tiles } = getState();\n  let dirOffset = MOVE_DIR[dir];\n  let score = 0;\n  let movingPromise;\n\n  for (let i=0; i<size; i++) {\n    for (let j=0; j<size; j++) {\n      let row = i, col = j;\n      if (dir === 'right') {\n        // reverse col to get right-to-left iteration\n        col = size - j - 1;\n      }\n      if (dir === 'down') {\n        // reverse row to get bottom-to-top iteration\n        row = size - i - 1;\n      }\n\n      // map <i, j> to <row, col> according direction `dir`\n      // every iteration, we have to get new state case\n      let tile = tiles[row][col];\n      if (!tile) continue; // current tile is empty\n\n      // detect next tile in the direction of `dir`\n      // firstly, get the next coordinate\n      let nextCol = col + dirOffset[0];\n      let nextRow = row + dirOffset[1];\n      let nextTile;\n\n      // ensure that we're still in game board\n      while (nextCol >= 0 && nextCol < size && nextRow >=0 && nextRow < size) {\n        nextTile = tiles[nextRow][nextCol];\n        if (nextTile) {\n          // found a non-empty tile in the dir direction, just break\n          break;\n        }\n        // next cell is empty, so walk forward the direction\n        nextCol += dirOffset[0];\n        nextRow += dirOffset[1];\n      }\n\n      if (nextTile && !nextTile.tileToMerge && nextTile.number === tile.number) {\n        // get the same number cell, and the cell is not new merged one\n        let payload = {\n          col, row,\n          destCol: nextCol,\n          destRow: nextRow\n        };\n\n        dispatch(preMergeTile(payload));\n        movingPromise = dispatch(moveTile(payload));\n\n        // then merge tile\n        // we don't chain this promise because we want the chess board can reponse immediately after moving not after merging\n        movingPromise.then(({destCol: col, destRow: row}) => {\n          dispatch(mergeTile({row, col}));\n        }).catch(reason => console.trace(reason));\n\n        ({ tiles } = getState());\n\n        score += nextTile.number + tile.number; // calculate score\n      } else {\n        // step back, put the cell next to nextCell\n        nextCol -= dirOffset[0];\n        nextRow -= dirOffset[1];\n        // if next cell is not the current cell\n        if (nextCol !== col || nextRow !== row) {\n          movingPromise = dispatch(moveTile({\n            row, col,\n            destRow: nextRow,\n            destCol: nextCol\n          }));\n          ({ tiles } = getState());\n        }\n      }\n    }\n  }\n\n  return {movingPromise, score};\n};\n\nexport * from './tiles';\nexport * from './scores';\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { connect } from 'react-redux';\nimport { cleanRecentAddedScore, startNewGame } from '../actions';\nimport './HeaderBox.css';\n\nconst ScoreBox = ({ label, score, children }) => {\n  return (\n    <div className=\"score-box\">\n      <div className=\"score-label\">{label}</div>\n      <div className=\"score-content\">{score}</div>\n      {children}\n    </div>\n  );\n};\n\nScoreBox.propTypes = {\n  label: PropTypes.string.isRequired,\n  score: PropTypes.number.isRequired\n};\n\nconst HeaderBox = (props) => {\n  return (\n    <div className=\"header-box\">\n      <h1 className=\"title\">2048</h1>\n      <ScoreBox score={props.score} label=\"SCORE\">\n      {\n        props.recentAddedScores.map((score) =>\n          <div className=\"addition-score\" key={score.id}\n            onAnimationEnd={(e) => props.onAnimationEnd(score.id)}\n          >+{score.score}</div>\n        )\n      }\n      </ScoreBox>\n      <ScoreBox score={props.bestScore} label=\"BEST\" />\n      <div className=\"desc-txt\">\n        <span className=\"bold\">Play 2048 Game Online</span><br/>\n        Join the numbers and get to the <span className=\"bold\">2048 tile!</span>\n      </div>\n      <button className=\"new-game-btn\" onClick={props.startNewGame}>New Game</button>\n    </div>\n  );\n};\n\nHeaderBox.propTypes = {\n  recentAddedScores: PropTypes.array.isRequired,\n  bestScore: PropTypes.number.isRequired,\n  score: PropTypes.number.isRequired,\n  onAnimationEnd: PropTypes.func.isRequired,\n  startNewGame: PropTypes.func.isRequired\n};\n\n\nconst mapStateToProps = ({scores}) => scores;\n\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    onAnimationEnd: id => dispatch(cleanRecentAddedScore(id)),\n    startNewGame: () => dispatch(startNewGame())\n  };\n};\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(HeaderBox);\n","import * as ActionTypes from './action-types';\n\nimport { v4 } from 'node-uuid';\n\nexport const addScore = (score) => {\n  return {\n    type: ActionTypes.ADD_SCORE,\n    id: v4(),\n    score\n  };\n};\n\nexport const cleanRecentAddedScore = (id) => {\n  return {\n    type: ActionTypes.CLEAN_RECENT_ADDED_SCORE,\n    id\n  };\n};\n\nexport const updateBestScore = (score) => (dispatch, getState) => {\n  let { scores: { bestScore }} = getState();\n  bestScore = Math.max(bestScore, score);\n  localStorage.setItem('bestScore', bestScore);\n\n  dispatch({\n    type: ActionTypes.UPDATE_BEST_SCORE,\n    bestScore\n  });\n};\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { startNewGame } from '../actions';\nimport { connect } from 'react-redux';\nimport './GameOver.css';\n\n\nlet GameOver = ({dispatch}) => {\n  return <div className=\"game-over\">\n    <h1 className=\"title\">Game Over!</h1>\n    <button onClick={() => dispatch(startNewGame())}>Try Again</button>\n  </div>;\n};\n\nGameOver.propTypes = {\n  dispatch: PropTypes.func.isRequired\n};\n\nexport default connect()(GameOver);\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport * as actions from '../actions';\nimport flatten from 'lodash.flatten';\nimport { connect } from 'react-redux';\nimport './Tiles.css';\n\nconst TILE_WIDTH = 100;\nconst TILE_GAP = 10;\n\nlet Tile = (props) => {\n  let {col, row} = props;\n  let classMap = {\n    tile: true,\n    [`tile-${props.number}`]: true,\n    'tile-new': props.newGenerated,\n    'tile-merged': !!props.newMerged\n  };\n  let classNames = Object.keys(classMap).filter(cls => !!classMap[cls]).join(' ');\n  let x = col * ( TILE_WIDTH + TILE_GAP) + 'px';\n  let y = row * ( TILE_WIDTH + TILE_GAP) + 'px';\n  let style = {transform: `translate3d(${x}, ${y}, 0)`};\n  return (\n    <div className={classNames} style={style}>\n      <div className=\"tile-inner\" onAnimationEnd={props.onAnimationEnd}>{props.number}</div>\n    </div>\n  );\n};\n\nTile.propTypes = {\n  col: PropTypes.number.isRequired,\n  row: PropTypes.number.isRequired,\n  number: PropTypes.number.isRequired,\n  newGenerated: PropTypes.bool.isRequired,\n  newMerged: PropTypes.bool.isRequired,\n  onAnimationEnd: PropTypes.func.isRequired\n};\n\nconst mapDispatchToTileProps = (dispatch, ownProps) => {\n  return {\n    onAnimationEnd({animationName}) {\n      // designed in css file\n      let { col, row } = ownProps;\n      if (animationName === 'a-tile-new') {\n        dispatch(actions.resetNewGeneratedTileTag({ col, row }));\n      } else if(animationName === 'a-tile-merged') {\n        dispatch(actions.resetNewMergedTileTag({ col, row }));\n      }\n    }\n  };\n};\n\nTile = connect(null, mapDispatchToTileProps)(Tile);\n\n\nconst Tiles = ({flatTiles}) => (\n  <div className=\"tile-container\">{flatTiles.map(tile =>\n    <Tile key={'tile-'+tile.uuid} {...tile}></Tile>\n  )}</div>\n);\n\nTiles.propTypes = {\n  flatTiles: PropTypes.array.isRequired\n};\n\nconst flattenTiles = tiles => {\n  let flatTiles = [];\n  flatten(tiles).filter(tile => !!tile).forEach(tile => {\n    flatTiles.push(tile);\n    if(tile.tileToMerge) {\n      flatTiles.push(tile.tileToMerge);\n    }\n  });\n  return flatTiles.sort((tile1, tile2) => tile1.uuid > tile2.uuid ? 1 : -1);\n};\n\nconst mapStateToProps = ({tiles}) => {\n  return {\n    flatTiles: flattenTiles(tiles)\n  };\n};\n\nexport default connect(mapStateToProps)(Tiles);\n","import React from 'react';\nimport HeaderBox from './HeaderBox';\nimport GameOver from './GameOver';\nimport Tiles from './Tiles';\nimport PropTypes from 'prop-types';\nimport { connect } from 'react-redux';\nimport './GameBoard.css';\n\nconst BackgroundGrids = ({size}) => {\n  let row = i => {\n    return new Array(size).fill().map((_, j) =>\n      <div className=\"grid-cell\" key={`grid-cell-${i * size + j}`}></div>\n    );\n  };\n  let grids = new Array(size).fill().map((_, i) => row(i));\n\n  return (\n    <div className=\"grid-container\">{grids}</div>\n  );\n};\n\nBackgroundGrids.propTypes = {\n  size: PropTypes.number.isRequired\n};\n\nconst GameBoard = (props) => (\n  <div className=\"game-board\">\n    <HeaderBox />\n    <div className=\"game-box\">\n      <BackgroundGrids size={props.size}/>\n      <Tiles/>\n      {props.gameOver && <GameOver />}\n    </div>\n    <a href=\"https://github.com/liuxiaole/2048-react-redux\" className=\"view-score-link\">view source on github</a>\n  </div>\n);\n\nGameBoard.propTypes = {\n  size: PropTypes.number.isRequired,\n  gameOver: PropTypes.bool.isRequired\n};\n\nconst mapStateToProps = state => {\n  return {\n    size: state.size,\n    gameOver: state.gameStatus === 'over'\n  };\n};\n\nexport default connect(mapStateToProps)(GameBoard);\n","import React, { Component } from 'react';\nimport GameBoard from './GameBoard';\nimport Swipeable from 'react-swipeable';\nimport { connect } from 'react-redux';\nimport * as actions from '../actions';\nimport { deepEach } from '../utils';\nimport PropTypes from 'prop-types';\n\nclass Game extends Component {\n  static propTypes = {\n    startNewGame: PropTypes.func.isRequired,\n    setGameOver: PropTypes.func.isRequired,\n    generateNewTile: PropTypes.func.isRequired,\n    moveChessBoard: PropTypes.func.isRequired,\n    addScore: PropTypes.func.isRequired,\n    updateBestScore: PropTypes.func.isRequired,\n    gameStarted: PropTypes.bool.isRequired,\n    size: PropTypes.number.isRequired,\n    tiles: PropTypes.array.isRequired,\n    score: PropTypes.number.isRequired\n  };\n\n  componentDidMount () {\n    this.props.startNewGame();\n    this.handleKeyPress = this.handleKeyPress.bind(this);\n    this.handleSwiped = this.handleSwiped.bind(this);\n    window.addEventListener('keydown', this.handleKeyPress);\n  }\n\n  componentWillUnmount () {\n    window.removeEventListener('keydown', this.handleKeyPress);\n  }\n\n  handleKeyPress (ev) {\n    let { key } = ev;\n\n    if (!this.props.gameStarted) return;\n    let match = key.toLowerCase().match(/arrow(up|right|down|left)/);\n    if (match) {\n      this.move(match[1]);\n      ev.preventDefault();\n    }\n  }\n\n  handleSwiped (dir) {\n    if (!this.props.gameStarted) return;\n    this.move(dir);\n    return false;\n  }\n\n  move (dir) {\n    if (this.isMoving) return;\n    let {movingPromise, score} = this.props.moveChessBoard(dir);\n    if (movingPromise) {\n      this.isMoving = true;\n      movingPromise.then(() => {\n        score && this.props.addScore(score);\n        this.isMoving = false;\n        this.props.generateNewTile();\n        this.checkGameStatus();\n      });\n    }\n  }\n\n  isMovable () {\n    let movable = false;\n    let { tiles, size } = this.props;\n    // check each tile,\n    // if there is any empty tile, sets movable to true\n    // if there is any adjacent tile which has the same number, sets movable to true\n    deepEach(tiles, tile => {\n      if (movable) return; // break;\n      if (!tile) {\n        movable = true;\n        return;\n      }\n      let {row: i, col: j} = tile;\n      if (i < size - 1) {\n        let bottomTile = tiles[i+1][j];\n        if (bottomTile && bottomTile.number === tile.number) {\n          movable = true;\n          return;\n        }\n      }\n\n      if (j < size - 1) {\n        let rightTile = tiles[i][j+1];\n        if (rightTile && rightTile.number === tile.number) {\n          movable = true;\n          return;\n        }\n      }\n    });\n\n    return movable;\n  }\n\n  checkGameStatus () {\n    if (!this.isMovable()) {\n      // game over\n      this.props.updateBestScore(this.props.score);\n      this.props.setGameOver();\n    }\n  }\n\n  render () {\n    let swipeOptions = ['up', 'right', 'down', 'left'].reduce((options, dir) => {\n      let propName = `on-swiped-${dir}`.replace(/-(\\w)/g, ($0, $1) => $1.toUpperCase());\n      options[propName] = this.handleSwiped.bind(this, dir);\n      return options;\n    }, {});\n\n    return  <Swipeable {...swipeOptions} preventDefaultTouchmoveEvent>\n      <GameBoard />\n    </Swipeable>;\n  }\n}\n\n\nconst mapStateToProps = (state) => {\n  return {\n    size: state.size,\n    tiles: state.tiles,\n    score: state.scores.score,\n    gameStarted: state.gameStatus === 'playing'\n  };\n};\n\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    startNewGame: () => dispatch(actions.startNewGame()),\n    setGameOver: () => dispatch(actions.setGameOver()),\n    generateNewTile: () => dispatch(actions.generateNewTile()),\n    moveChessBoard: dir => dispatch(actions.moveChessBoard(dir)),\n    addScore: score => dispatch(actions.addScore(score)),\n    updateBestScore: score => dispatch(actions.updateBestScore(score))\n  };\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Game);\n","import * as ActionTypes from '../actions/action-types';\nimport { combineReducers } from 'redux';\n\n\nconst score = (state=0, action) => {\n  switch(action.type) {\n    case ActionTypes.START_NEW_GAME:\n      return 0;\n    case ActionTypes.ADD_SCORE:\n      return state + action.score;\n    default:\n      return state;\n  }\n};\n\nconst recentAddedScores = (state=[], action) => {\n  switch(action.type) {\n    case ActionTypes.START_NEW_GAME:\n      return [];\n\n    case ActionTypes.ADD_SCORE:\n      return [...state, {score: action.score, id: action.id}];\n\n    case ActionTypes.CLEAN_RECENT_ADDED_SCORE:\n      return state.filter(score => score.id !== action.id);\n\n    default:\n      return state;\n  }\n};\n\nconst bestScore = (state=0, action) => {\n  switch(action.type) {\n    case ActionTypes.UPDATE_BEST_SCORE:\n      return action.bestScore;\n    default:\n      return state;\n  }\n};\n\nexport default combineReducers({\n  score, bestScore, recentAddedScores\n});\n","import * as ActionTypes from '../actions/action-types';\n\nconst getInitialTiles = size => {\n  let tiles = [];\n  for (let i = 0; i < size; i++) {\n    let row = tiles[i] = [];\n    for (let j = 0; j < size; j++) {\n      row[j] = null;\n    }\n  }\n  return tiles;\n};\n\nconst mapTiles = (tiles, row, col) => {\n  return mapper => {\n    return tiles.map((rows, rowNum) => {\n      if(rowNum !== row) return rows;\n      return rows.map((tile, colNum) => {\n        if(colNum !== col) return tile;\n        return mapper(tile);\n      });\n    });\n  };\n};\n\nconst tile = (state = null, action) => {\n  switch(action.type) {\n    case ActionTypes.GENERATE_NEW_TILE:\n      return {\n        number: action.number,\n        newGenerated: true,\n        newMerged: false,\n        tileToMerge: null,\n        uuid: action.uuid,\n        col: action.col,\n        row: action.row\n      };\n\n    case ActionTypes.RESET_NEW_GENERATED_TILE_TAG:\n      return {\n        ...state,\n        newGenerated: false\n      };\n\n    case ActionTypes.MERGE_TILE:\n      return {\n        ...state,\n        number: state.number + state.tileToMerge.number,\n        newMerged: true\n      };\n    case ActionTypes.PRE_MERGE_TILE:\n      return {\n        ...state,\n        tileToMerge: action.tileToMerge\n      };\n\n    case ActionTypes.RESET_NEW_MERGED_TILE_TAG:\n      return {\n        ...state,\n        newMerged: false,\n        tileToMerge: null\n      };\n\n    default:\n      return state;\n  }\n};\n\nconst tiles = (state = [], action) => {\n  switch(action.type) {\n    case ActionTypes.START_NEW_GAME:\n      return getInitialTiles(action.size);\n\n    case ActionTypes.GENERATE_NEW_TILE:\n    case ActionTypes.RESET_NEW_MERGED_TILE_TAG:\n    case ActionTypes.RESET_NEW_GENERATED_TILE_TAG:\n    case ActionTypes.MERGE_TILE:\n      return mapTiles(state, action.row, action.col)(item => tile(item, action));\n\n    case ActionTypes.PRE_MERGE_TILE:\n      let tileToMerge = state[action.destRow][action.destCol];\n      state = mapTiles(state, action.row, action.col)(item =>\n        tile(item, {...action, tileToMerge})\n      );\n      return mapTiles(state, action.destRow, action.destCol)(item => null);\n\n    case ActionTypes.MOVE_TILE:\n      let tileToMove = state[action.row][action.col];\n      state = mapTiles(state, action.row, action.col)(item => null); // delete source tile\n      return mapTiles(state, action.destRow, action.destCol)(item => {\n        return {\n          ...tileToMove,\n          col: action.destCol,\n          row: action.destRow\n        };\n      });\n\n    default:\n      return state;\n  }\n};\n\nexport default tiles;\n","import * as ActionTypes from '../actions/action-types';\nimport { combineReducers } from 'redux';\nimport scores from './scores';\nimport tiles from './tiles';\n\n\nconst gameStatus = (state = 'over', action) => {\n  switch(action.type) {\n  case ActionTypes.START_NEW_GAME:\n    return 'playing';\n  case ActionTypes.GAME_OVER:\n    return 'over';\n  default:\n    return state;\n  }\n};\n\nexport default combineReducers({\n  size: () => 4,\n  scores,\n  tiles,\n  gameStatus\n});\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport Game from './components/Game';\nimport './index.css';\n\nimport { Provider } from 'react-redux';\nimport { createStore, applyMiddleware, compose } from 'redux';\nimport thunk from 'redux-thunk';\nimport rootReducer from './reducers';\n\n\n/* eslint-disable no-underscore-dangle */\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\n/* eslint-enable */\n\nconst preloadedState = {};\n\ntry {\n  let bestScore = localStorage.getItem('bestScore');\n  if(bestScore) {\n    bestScore = JSON.parse(bestScore);\n    preloadedState.scores = { bestScore };\n  }\n} catch(e){}\n\nconst store = createStore(rootReducer, preloadedState, composeEnhancers(\n  applyMiddleware(thunk)\n));\n\nReactDOM.render(\n  <Provider store={store}>\n    <Game />\n  </Provider>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}